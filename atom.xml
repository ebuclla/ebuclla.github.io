<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-10-18T05:14:25.637Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-300</title>
    <link href="http://example.com/2025/10/18/leetcode-300/"/>
    <id>http://example.com/2025/10/18/leetcode-300/</id>
    <published>2025-10-18T05:12:50.000Z</published>
    <updated>2025-10-18T05:14:25.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h1><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p>递推公式</p><p>dp[0] = 1</p><p>dp[1] = nums[1]&gt;nums[0]?2:1</p><p>dp[i] = max(dp[j]) + 1 if nums[i] &gt; nums[j]</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(length, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>]&gt;nums[<span class="number">0</span>]?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++){</span><br><span class="line">                <span class="keyword">if</span>((nums[i] &gt; nums[j]) &amp;&amp; (dp[i] &lt;= dp[j]))</span><br><span class="line">                {</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;300. 最长递增子序列&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中</summary>
      
    
    
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-192</title>
    <link href="http://example.com/2025/10/16/leetcode-198/"/>
    <id>http://example.com/2025/10/16/leetcode-198/</id>
    <published>2025-10-16T07:26:05.000Z</published>
    <updated>2025-10-16T07:29:30.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-192-打家劫舍"><a href="#Leetcode-192-打家劫舍" class="headerlink" title="Leetcode 192 打家劫舍"></a>Leetcode 192 打家劫舍</h1><p>题目描述</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p>状态转移方程<br>$$<br>dp[n] = max(dp[n-1],dp[n-2]+nums[n])<br>$$<br>初始状态</p><p>只有一家时，只能偷唯一一家nums[i]，两家时，偷的是两家中最大的一家，代码如下</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">// dp[n] = max(dp[n-1] , dp[n-2] + nums[n])</span></span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp0 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp1 = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> tmp = dp1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; length;i++)</span><br><span class="line">        {</span><br><span class="line">            tmp =dp1;</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0 + nums[i]);</span><br><span class="line">            dp0 = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leetcode-192-打家劫舍&quot;&gt;&lt;a href=&quot;#Leetcode-192-打家劫舍&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 192 打家劫舍&quot;&gt;&lt;/a&gt;Leetcode 192 打家劫舍&lt;/h1&gt;&lt;p&gt;题目描述&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 70</title>
    <link href="http://example.com/2025/10/16/leetcode-70/"/>
    <id>http://example.com/2025/10/16/leetcode-70/</id>
    <published>2025-10-16T06:26:48.000Z</published>
    <updated>2025-10-16T07:29:21.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-70-爬楼梯"><a href="#leetcode-70-爬楼梯" class="headerlink" title="leetcode 70 爬楼梯"></a>leetcode 70 爬楼梯</h1><p>题目描述</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>一个动态规划问题</p><p>状态转移方程<br>$$<br>times[s] = times[s-1] + times[s-2]<br>$$<br>初始状态，第一层爬法有1种，第零层有0种，代码为</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">// times[s] = times[s-1] + times[s-2]   </span></span><br><span class="line">        <span class="type">int</span> s = <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> s_1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">            tmp = s;</span><br><span class="line">            s = s + s_1;</span><br><span class="line">            s_1 = tmp; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode-70-爬楼梯&quot;&gt;&lt;a href=&quot;#leetcode-70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;leetcode 70 爬楼梯&quot;&gt;&lt;/a&gt;leetcode 70 爬楼梯&lt;/h1&gt;&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;假设你正在爬</summary>
      
    
    
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>测试博客</title>
    <link href="http://example.com/2025/10/15/test-blog/"/>
    <id>http://example.com/2025/10/15/test-blog/</id>
    <published>2025-10-15T13:02:37.919Z</published>
    <updated>2025-10-15T13:48:32.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试用博客"><a href="#测试用博客" class="headerlink" title="测试用博客"></a>测试用博客</h1><p><img lazyload="" src="/images/loading.svg" data-src="/2025/10/15/test-blog/image-20251015210351817.png" alt="一个测试图片"></p><p>为什么</p><p><img lazyload="" src="/images/loading.svg" data-src="/2025/10/15/test-blog/image-20251015214532625.png" alt="第二个测试图片"></p>]]></content>
    
    
    <summary type="html">无</summary>
    
    
    
    
  </entry>
  
</feed>
