[{"title":"leetcode-172","date":"2025-10-20T02:28:12.000Z","path":"2025/10/20/leetcode-172/","text":"Leetcode 172 阶乘后的零给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1 由于对于任意的n! 只需要一个因子5和一个因子2就可以贡献一个尾部的0，而很明显，2因子明显比5因子多得多，实际上我们只需要考虑n!有多少个因子5就可以了 可以得知，n 每增长 5 ，就会多一个因子5，每增长25，就会多两个因子5，以此类推，每增长5^n^，就会多n个因子五， 实际计算过程中，可以把25的一个因子按照每增长5多一个因子 每增长25多一个因子共同组成了25的两个因子来计算，换句话说，可以抽象成下面的公式$$r_zero = \\sum_{k=1}^{n&lt;5^k}\\frac{n}{5^k}$$ 123456789101112class Solution {public: int trailingZeroes(int n) { long i = 5; int r_zero = 0; while(n &gt;= i){ r_zero = r_zero + n / i; i = i * 5; } return r_zero; }};","tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"leetcode-300","date":"2025-10-18T05:12:50.000Z","path":"2025/10/18/leetcode-300/","text":"300. 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 递推公式 dp[0] = 1 dp[1] = nums[1]&gt;nums[0]?2:1 dp[i] = max(dp[j]) + 1 if nums[i] &gt; nums[j] 12345678910111213141516171819202122class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int length = nums.size(); if(length == 1) return 1; vector&lt;int&gt; dp(length, 1); dp[0] = 1; dp[1] = nums[1]&gt;nums[0]?2:1; for(int i = 1; i &lt; length; i++) { for(int j = 0; j &lt; i; j++){ if((nums[i] &gt; nums[j]) &amp;&amp; (dp[i] &lt;= dp[j])) { dp[i] = dp[j] + 1; } } } return *max_element(dp.begin(), dp.end()); }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode-192","date":"2025-10-16T07:26:05.000Z","path":"2025/10/16/leetcode-198/","text":"Leetcode 192 打家劫舍题目描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 状态转移方程$$dp[n] = max(dp[n-1],dp[n-2]+nums[n])$$初始状态 只有一家时，只能偷唯一一家nums[i]，两家时，偷的是两家中最大的一家，代码如下 123456789101112131415161718class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { // dp[n] = max(dp[n-1] , dp[n-2] + nums[n]) int length = nums.size(); if(length == 1) return nums[0]; int dp0 = nums[0]; int dp1 = max(nums[0], nums[1]); int tmp = dp1; for(int i = 2;i &lt; length;i++) { tmp =dp1; dp1 = max(dp1, dp0 + nums[i]); dp0 = tmp; } return dp1; }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode 70","date":"2025-10-16T06:26:48.000Z","path":"2025/10/16/leetcode-70/","text":"leetcode 70 爬楼梯题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 一个动态规划问题 状态转移方程$$times[s] = times[s-1] + times[s-2]$$初始状态，第一层爬法有1种，第零层有0种，代码为 123456789101112131415class Solution {public: int climbStairs(int n) { // times[s] = times[s-1] + times[s-2] int s = 1 ; int s_1 = 0 ; int tmp = 0 ; for(int i = 1; i &lt;= n; i++){ tmp = s; s = s + s_1; s_1 = tmp; } return s; }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"测试博客","date":"2025-10-15T13:02:37.919Z","path":"2025/10/15/test-blog/","text":"测试用博客 为什么","tags":[]}]