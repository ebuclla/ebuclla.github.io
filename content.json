[{"title":"leetcode-300","date":"2025-10-18T05:12:50.000Z","path":"2025/10/18/leetcode-300/","text":"300. 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 递推公式 dp[0] = 1 dp[1] = nums[1]&gt;nums[0]?2:1 dp[i] = max(dp[j]) + 1 if nums[i] &gt; nums[j] 12345678910111213141516171819202122class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int length = nums.size(); if(length == 1) return 1; vector&lt;int&gt; dp(length, 1); dp[0] = 1; dp[1] = nums[1]&gt;nums[0]?2:1; for(int i = 1; i &lt; length; i++) { for(int j = 0; j &lt; i; j++){ if((nums[i] &gt; nums[j]) &amp;&amp; (dp[i] &lt;= dp[j])) { dp[i] = dp[j] + 1; } } } return *max_element(dp.begin(), dp.end()); }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode-192","date":"2025-10-16T07:26:05.000Z","path":"2025/10/16/leetcode-198/","text":"Leetcode 192 打家劫舍题目描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 状态转移方程$$dp[n] = max(dp[n-1],dp[n-2]+nums[n])$$初始状态 只有一家时，只能偷唯一一家nums[i]，两家时，偷的是两家中最大的一家，代码如下 123456789101112131415161718class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { // dp[n] = max(dp[n-1] , dp[n-2] + nums[n]) int length = nums.size(); if(length == 1) return nums[0]; int dp0 = nums[0]; int dp1 = max(nums[0], nums[1]); int tmp = dp1; for(int i = 2;i &lt; length;i++) { tmp =dp1; dp1 = max(dp1, dp0 + nums[i]); dp0 = tmp; } return dp1; }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode 70","date":"2025-10-16T06:26:48.000Z","path":"2025/10/16/leetcode-70/","text":"leetcode 70 爬楼梯题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 一个动态规划问题 状态转移方程$$times[s] = times[s-1] + times[s-2]$$初始状态，第一层爬法有1种，第零层有0种，代码为 123456789101112131415class Solution {public: int climbStairs(int n) { // times[s] = times[s-1] + times[s-2] int s = 1 ; int s_1 = 0 ; int tmp = 0 ; for(int i = 1; i &lt;= n; i++){ tmp = s; s = s + s_1; s_1 = tmp; } return s; }};","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"测试博客","date":"2025-10-15T13:02:37.919Z","path":"2025/10/15/test-blog/","text":"测试用博客 为什么","tags":[]}]